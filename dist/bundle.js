(() => {
  let e; let r; const n = {
    396: () => {
      function e(e, n) {
        let t = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (!t) {
          if (Array.isArray(e) || (t = (function (e, n) { if (e) { if (typeof e === 'string') return r(e, n); let t = Object.prototype.toString.call(e).slice(8, -1); return t === 'Object' && e.constructor && (t = e.constructor.name), t === 'Map' || t === 'Set' ? Array.from(e) : t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? r(e, n) : void 0; } }(e))) || n && e && typeof e.length === 'number') {
            t && (e = t); let o = 0; const i = function () {}; return {
              s: i, n() { return o >= e.length ? { done: !0 } : { done: !1, value: e[o++] }; }, e(e) { throw e; }, f: i,
            };
          } throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
        } let a; let c = !0; let d = !1; return {
          s() { t = t.call(e); }, n() { const e = t.next(); return c = e.done, e; }, e(e) { d = !0, a = e; }, f() { try { c || t.return == null || t.return(); } finally { if (d) throw a; } },
        };
      } function r(e, r) { (r == null || r > e.length) && (r = e.length); for (var n = 0, t = new Array(r); n < r; n++)t[n] = e[n]; return t; }document.querySelector('#flash-card-page'), document.querySelector('#landing-page'); const n = document.querySelector('#submit-btn'); const t = document.querySelector('.filter-list'); const o = Array.from(document.getElementsByClassName('qty')); const a = document.querySelector('.images-container'); const c = []; console.log('production AND ALL other env variables logging out'), CloudKit.configure({ containers: [{ containerIdentifier: 'iCloud.com.vbmapp.flashcards', apiTokenAuth: { apiToken: '6c58c1d30286dd3680cdf72979b1b3418480809d92fc9b0e3a3c8b8998bb36ab', persist: !0, serverToServerKeyAuth: { keyID: '5V3RA3367C', privateKeyFile: '../config/AuthKey.p8' } }, environment: 'production' }] }), CloudKit.getDefaultContainer(); const d = CloudKit.getDefaultContainer().publicCloudDatabase; CloudKit.getDefaultContainer().privateCloudDatabase, document.addEventListener('AppleIDSignInOnSuccess', ((e) => { console.log('Apple ID sign in successful: ', e.detail.data); })), document.addEventListener('AppleIDSignInOnFailure', ((e) => { console.log('Apple ID sign in failed: ', e.detail.error); })), d.performQuery({}).then(((e) => {})).catch(((e) => {})); const l = function (r) { r.sort(); let n; const o = e(r); try { for (o.s(); !(n = o.n()).done;) { const i = n.value; const a = document.createElement('div'); a.classList.add('filter-item', 'center'); const c = document.createElement('label'); c.classList.add('name', 'center'), c.htmlFor = i, c.innerText = i; const d = document.createElement('input'); d.classList.add('qty', 'center'), d.type = 'text', d.id = fileName, d.placeholder = 0, a.appendChild(c), a.appendChild(d), t.appendChild(a); } } catch (e) { o.e(e); } finally { o.f(); } }; l(c), n.addEventListener('click', (() => { const e = []; const r = []; o.forEach(((n) => { n.value && (e.push(n.id), r.push(n.value)); })), u(e, r), CloudKit.getDefaultContainer().publicCloudDatabase.performQuery({ recordType: 'Albums', filterBy: [{ fieldName: 'parent', comparator: 'EQUALS', fieldValue: { value: 'VB-MAPP-FC' } }] }).then(((e) => { if (e.hasErrors)console.error(e.errors[0]); else { for (let r = e.records, n = 0; n < r.length; n++) { const t = r[n].fields.name.value; c.push(t); }l(c); } })); })); var u = function (r, n) { for (var t = CloudKit.getDefaultContainer().publicCloudDatabase, o = [], a = 0; a < r.length; a++) { const c = { recordType: 'Photos', filterBy: [{ fieldName: 'album', comparator: 'EQUALS', fieldValue: { value: r[a] } }] }; o.push(t.performQuery(c)); }Promise.all(o).then(((r) => { let t; let o = []; const a = e(r); try { for (a.s(); !(t = a.n()).done;) { var c; const d = t.value.records; let l = []; const u = e(d); try { for (u.s(); !(c = u.n()).done;) { const p = c.value.fields.image.value; l.push(p); } } catch (e) { u.e(e); } finally { u.f(); }s(l), l = l.slice(0, n[i]), o = o.concat(l); } } catch (e) { a.e(e); } finally { a.f(); }s(o), f(o); })); }; var s = function (e) { for (let r = e.length - 1; r > 0; r--) { const n = Math.floor(Math.random() * (r + 1)); const t = [e[n], e[r]]; e[r] = t[0], e[n] = t[1]; } return e; }; var f = function (e) { a.innerHTML = ''; for (let r = 0; r < e.length; r++) { const n = document.createElement('img'); n.src = e[r], a.appendChild(n); } };
    },
  }; const t = {}; function o(e) {
    const r = t[e]; if (void 0 !== r) { if (void 0 !== r.error) throw r.error; return r.exports; } let i = t[e] = { exports: {} }; try {
      const a = {
        id: e, module: i, factory: n[e], require: o,
      }; o.i.forEach(((e) => { e(a); })), i = a.module, a.factory.call(i.exports, i, i.exports, a.require);
    } catch (e) { throw i.error = e, e; } return i.exports;
  }o.m = n, o.c = t, o.i = [], o.hu = (e) => `${e}.${o.h()}.hot-update.js`, o.hmrF = () => `main.${o.h()}.hot-update.json`, o.h = () => 'f6179d570877f272b5d3', o.g = (function () { if (typeof globalThis === 'object') return globalThis; try { return this || new Function('return this')(); } catch (e) { if (typeof window === 'object') return window; } }()), o.o = (e, r) => Object.prototype.hasOwnProperty.call(e, r), e = {}, r = 'flash-cards:', o.l = (n, t, i, a) => { if (e[n])e[n].push(t); else { let c; let d; if (void 0 !== i) for (let l = document.getElementsByTagName('script'), u = 0; u < l.length; u++) { const s = l[u]; if (s.getAttribute('src') == n || s.getAttribute('data-webpack') == r + i) { c = s; break; } }c || (d = !0, (c = document.createElement('script')).charset = 'utf-8', c.timeout = 120, o.nc && c.setAttribute('nonce', o.nc), c.setAttribute('data-webpack', r + i), c.src = n), e[n] = [t]; const f = (r, t) => { c.onerror = c.onload = null, clearTimeout(p); const o = e[n]; if (delete e[n], c.parentNode && c.parentNode.removeChild(c), o && o.forEach(((e) => e(t))), r) return r(t); }; var p = setTimeout(f.bind(null, void 0, { type: 'timeout', target: c }), 12e4); c.onerror = f.bind(null, c.onerror), c.onload = f.bind(null, c.onload), d && document.head.appendChild(c); } }, (() => {
    let e; let r; let n; const t = {}; const i = o.c; let a = []; const c = []; let d = 'idle'; let l = 0; let u = []; function s(e) { d = e; for (var r = [], n = 0; n < c.length; n++)r[n] = c[n].call(null, e); return Promise.all(r); } function f() { --l == 0 && s('ready').then((() => { if (l === 0) { const e = u; u = []; for (let r = 0; r < e.length; r++)e[r](); } })); } function p(e) { if (d !== 'idle') throw new Error('check() is only allowed in idle status'); return s('check').then(o.hmrM).then(((n) => (n ? s('prepare').then((() => { const t = []; return r = [], Promise.all(Object.keys(o.hmrC).reduce(((e, i) => (o.hmrC[i](n.c, n.r, n.m, e, r, t), e)), [])).then((() => { return r = function () { return e ? v(e) : s('ready').then((() => t)); }, l === 0 ? r() : new Promise(((e) => { u.push((() => { e(r()); })); })); let r; })); })) : s(m() ? 'ready' : 'idle').then((() => null))))); } function h(e) { return d !== 'ready' ? Promise.resolve().then((() => { throw new Error(`apply() is only allowed in ready status (state: ${d})`); })) : v(e); } function v(e) { e = e || {}, m(); const t = r.map(((r) => r(e))); r = void 0; const o = t.map(((e) => e.error)).filter(Boolean); if (o.length > 0) return s('abort').then((() => { throw o[0]; })); const i = s('dispose'); t.forEach(((e) => { e.dispose && e.dispose(); })); let a; const c = s('apply'); const d = function (e) { a || (a = e); }; const l = []; return t.forEach(((e) => { if (e.apply) { const r = e.apply(d); if (r) for (let n = 0; n < r.length; n++)l.push(r[n]); } })), Promise.all([i, c]).then((() => (a ? s('fail').then((() => { throw a; })) : n ? v(e).then(((e) => (l.forEach(((r) => { e.indexOf(r) < 0 && e.push(r); })), e))) : s('idle').then((() => l))))); } function m() { if (n) return r || (r = []), Object.keys(o.hmrI).forEach(((e) => { n.forEach(((n) => { o.hmrI[e](n, r); })); })), n = void 0, !0; }o.hmrD = t, o.i.push(((u) => {
      let v; let m; let y; let g; const b = u.module; const E = (function (r, n) {
        const t = i[n]; if (!t) return r; const o = function (o) { if (t.hot.active) { if (i[o]) { const c = i[o].parents; c.indexOf(n) === -1 && c.push(n); } else a = [n], e = o; t.children.indexOf(o) === -1 && t.children.push(o); } else console.warn(`[HMR] unexpected require(${o}) from disposed module ${n}`), a = []; return r(o); }; const c = function (e) {
          return {
            configurable: !0, enumerable: !0, get() { return r[e]; }, set(n) { r[e] = n; },
          };
        }; for (const u in r)Object.prototype.hasOwnProperty.call(r, u) && u !== 'e' && Object.defineProperty(o, u, c(u)); return o.e = function (e) { return (function (e) { switch (d) { case 'ready': s('prepare'); case 'prepare': return l++, e.then(f, f), e; default: return e; } }(r.e(e))); }, o;
      }(u.require, u.id)); b.hot = (v = u.id, m = b, g = {
        _acceptedDependencies: {}, _acceptedErrorHandlers: {}, _declinedDependencies: {}, _selfAccepted: !1, _selfDeclined: !1, _selfInvalidated: !1, _disposeHandlers: [], _main: y = e !== v, _requireSelf() { a = m.parents.slice(), e = y ? void 0 : v, o(v); }, active: !0, accept(e, r, n) { if (void 0 === e)g._selfAccepted = !0; else if (typeof e === 'function')g._selfAccepted = e; else if (typeof e === 'object' && e !== null) for (let t = 0; t < e.length; t++)g._acceptedDependencies[e[t]] = r || function () {}, g._acceptedErrorHandlers[e[t]] = n; else g._acceptedDependencies[e] = r || function () {}, g._acceptedErrorHandlers[e] = n; }, decline(e) { if (void 0 === e)g._selfDeclined = !0; else if (typeof e === 'object' && e !== null) for (let r = 0; r < e.length; r++)g._declinedDependencies[e[r]] = !0; else g._declinedDependencies[e] = !0; }, dispose(e) { g._disposeHandlers.push(e); }, addDisposeHandler(e) { g._disposeHandlers.push(e); }, removeDisposeHandler(e) { const r = g._disposeHandlers.indexOf(e); r >= 0 && g._disposeHandlers.splice(r, 1); }, invalidate() { switch (this._selfInvalidated = !0, d) { case 'idle': r = [], Object.keys(o.hmrI).forEach(((e) => { o.hmrI[e](v, r); })), s('ready'); break; case 'ready': Object.keys(o.hmrI).forEach(((e) => { o.hmrI[e](v, r); })); break; case 'prepare': case 'check': case 'dispose': case 'apply': (n = n || []).push(v); } }, check: p, apply: h, status(e) { if (!e) return d; c.push(e); }, addStatusHandler(e) { c.push(e); }, removeStatusHandler(e) { const r = c.indexOf(e); r >= 0 && c.splice(r, 1); }, data: t[v],
      }, e = void 0, g), b.parents = a, b.children = [], a = [], u.require = E;
    })), o.hmrC = {}, o.hmrI = {};
  })(), (() => { let e; o.g.importScripts && (e = `${o.g.location}`); const r = o.g.document; if (!e && r && (r.currentScript && (e = r.currentScript.src), !e)) { const n = r.getElementsByTagName('script'); n.length && (e = n[n.length - 1].src); } if (!e) throw new Error('Automatic publicPath is not supported in this browser'); e = e.replace(/#.*$/, '').replace(/\?.*$/, '').replace(/\/[^\/]+$/, '/'), o.p = e; })(), (() => {
    let e; let r; let n; let t; let i; const a = o.hmrS_jsonp = o.hmrS_jsonp || { 179: 0 }; const c = {}; function d(r, n) { return e = n, new Promise(((e, n) => { c[r] = e; const t = o.p + o.hu(r); const i = new Error(); o.l(t, ((e) => { if (c[r]) { c[r] = void 0; const t = e && (e.type === 'load' ? 'missing' : e.type); const o = e && e.target && e.target.src; i.message = `Loading hot update chunk ${r} failed.\n(${t}: ${o})`, i.name = 'ChunkLoadError', i.type = t, i.request = o, n(i); } })); })); } function l(e) {
      function c(e) {
        for (var r = [e], n = {}, t = r.map(((e) => ({ chain: [e], id: e }))); t.length > 0;) {
          const i = t.pop(); const a = i.id; const c = i.chain; const l = o.c[a]; if (l && (!l.hot._selfAccepted || l.hot._selfInvalidated)) {
            if (l.hot._selfDeclined) return { type: 'self-declined', chain: c, moduleId: a }; if (l.hot._main) return { type: 'unaccepted', chain: c, moduleId: a }; for (let u = 0; u < l.parents.length; u++) {
              const s = l.parents[u]; const f = o.c[s]; if (f) {
                if (f.hot._declinedDependencies[a]) {
                  return {
                    type: 'declined', chain: c.concat([s]), moduleId: a, parentId: s,
                  };
                } r.indexOf(s) === -1 && (f.hot._acceptedDependencies[a] ? (n[s] || (n[s] = []), d(n[s], [a])) : (delete n[s], r.push(s), t.push({ chain: c.concat([s]), id: s })));
              }
            }
          }
        } return {
          type: 'accepted', moduleId: e, outdatedModules: r, outdatedDependencies: n,
        };
      } function d(e, r) { for (let n = 0; n < r.length; n++) { const t = r[n]; e.indexOf(t) === -1 && e.push(t); } }o.f && delete o.f.jsonpHmr, r = void 0; const l = {}; const u = []; const s = {}; const f = function (e) { console.warn(`[HMR] unexpected require(${e.id}) to disposed module`); }; for (let p in n) if (o.o(n, p)) { var h; const v = n[p]; let m = !1; let y = !1; let g = !1; let b = ''; switch ((h = v ? c(p) : { type: 'disposed', moduleId: p }).chain && (b = `\nUpdate propagation: ${h.chain.join(' -> ')}`), h.type) { case 'self-declined': e.onDeclined && e.onDeclined(h), e.ignoreDeclined || (m = new Error(`Aborted because of self decline: ${h.moduleId}${b}`)); break; case 'declined': e.onDeclined && e.onDeclined(h), e.ignoreDeclined || (m = new Error(`Aborted because of declined dependency: ${h.moduleId} in ${h.parentId}${b}`)); break; case 'unaccepted': e.onUnaccepted && e.onUnaccepted(h), e.ignoreUnaccepted || (m = new Error(`Aborted because ${p} is not accepted${b}`)); break; case 'accepted': e.onAccepted && e.onAccepted(h), y = !0; break; case 'disposed': e.onDisposed && e.onDisposed(h), g = !0; break; default: throw new Error(`Unexception type ${h.type}`); } if (m) return { error: m }; if (y) for (p in s[p] = v, d(u, h.outdatedModules), h.outdatedDependencies)o.o(h.outdatedDependencies, p) && (l[p] || (l[p] = []), d(l[p], h.outdatedDependencies[p])); g && (d(u, [h.moduleId]), s[p] = f); }n = void 0; for (var E, w = [], D = 0; D < u.length; D++) { const I = u[D]; const _ = o.c[I]; _ && (_.hot._selfAccepted || _.hot._main) && s[I] !== f && !_.hot._selfInvalidated && w.push({ module: I, require: _.hot._requireSelf, errorHandler: _.hot._selfAccepted }); } return {
        dispose() { let e; t.forEach(((e) => { delete a[e]; })), t = void 0; for (var r, n = u.slice(); n.length > 0;) { const i = n.pop(); var c = o.c[i]; if (c) { const d = {}; const s = c.hot._disposeHandlers; for (D = 0; D < s.length; D++)s[D].call(null, d); for (o.hmrD[i] = d, c.hot.active = !1, delete o.c[i], delete l[i], D = 0; D < c.children.length; D++) { const f = o.c[c.children[D]]; f && (e = f.parents.indexOf(i)) >= 0 && f.parents.splice(e, 1); } } } for (const p in l) if (o.o(l, p) && (c = o.c[p])) for (E = l[p], D = 0; D < E.length; D++)r = E[D], (e = c.children.indexOf(r)) >= 0 && c.children.splice(e, 1); },
        apply(r) {
          for (const n in s)o.o(s, n) && (o.m[n] = s[n]); for (let t = 0; t < i.length; t++)i[t](o); for (const a in l) {
            if (o.o(l, a)) {
              const c = o.c[a]; if (c) {
                E = l[a]; for (var d = [], f = [], p = [], h = 0; h < E.length; h++) { const v = E[h]; const m = c.hot._acceptedDependencies[v]; const y = c.hot._acceptedErrorHandlers[v]; if (m) { if (d.indexOf(m) !== -1) continue; d.push(m), f.push(y), p.push(v); } } for (let g = 0; g < d.length; g++) {
                  try { d[g].call(null, E); } catch (n) {
                    if (typeof f[g] === 'function') {
                      try { f[g](n, { moduleId: a, dependencyId: p[g] }); } catch (t) {
                        e.onErrored && e.onErrored({
                          type: 'accept-error-handler-errored', moduleId: a, dependencyId: p[g], error: t, originalError: n,
                        }), e.ignoreErrored || (r(t), r(n));
                      }
                    } else {
                      e.onErrored && e.onErrored({
                        type: 'accept-errored', moduleId: a, dependencyId: p[g], error: n,
                      }), e.ignoreErrored || r(n);
                    }
                  }
                }
              }
            }
          } for (let b = 0; b < w.length; b++) {
            const D = w[b]; const I = D.module; try { D.require(I); } catch (n) {
              if (typeof D.errorHandler === 'function') {
                try { D.errorHandler(n, { moduleId: I, module: o.c[I] }); } catch (t) {
                  e.onErrored && e.onErrored({
                    type: 'self-accept-error-handler-errored', moduleId: I, error: t, originalError: n,
                  }), e.ignoreErrored || (r(t), r(n));
                }
              } else e.onErrored && e.onErrored({ type: 'self-accept-errored', moduleId: I, error: n }), e.ignoreErrored || r(n);
            }
          } return u;
        },
      };
    }self.webpackHotUpdateflash_cards = (r, t, a) => { for (const d in t)o.o(t, d) && (n[d] = t[d], e && e.push(d)); a && i.push(a), c[r] && (c[r](), c[r] = void 0); }, o.hmrI.jsonp = function (e, r) { n || (n = {}, i = [], t = [], r.push(l)), o.o(n, e) || (n[e] = o.m[e]); }, o.hmrC.jsonp = function (e, c, u, s, f, p) { f.push(l), r = {}, t = c, n = u.reduce(((e, r) => (e[r] = !1, e)), {}), i = [], e.forEach(((e) => { o.o(a, e) && void 0 !== a[e] ? (s.push(d(e, p)), r[e] = !0) : r[e] = !1; })), o.f && (o.f.jsonpHmr = function (e, n) { r && o.o(r, e) && !r[e] && (n.push(d(e)), r[e] = !0); }); }, o.hmrM = () => { if (typeof fetch === 'undefined') throw new Error('No browser support: need fetch API'); return fetch(o.p + o.hmrF()).then(((e) => { if (e.status !== 404) { if (!e.ok) throw new Error(`Failed to fetch update manifest ${e.statusText}`); return e.json(); } })); };
  })(), o(396);
})();
